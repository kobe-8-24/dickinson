## Referer

[Mysql官方文档 - 英文](https://dev.mysql.com/doc/)

[MySQL 中文文档 | MySQL 中文网](https://www.mysqlzh.com/)


### 索引

```
1、分类
	b+树、b树、全文索引、hash、Rtree
	聚集索引、普通索引（二级索引、非聚集索引）
	普通索引、唯一索引、组合索引、主键索引
	
2、索引失效场景
    - 遇到范围查询（>、<、between、like）就会停止匹配
    - 违反最左匹配原则
    - 在索引列上做任何操作，例如函数、日期转换
    - 使用不等于（!= 、<>）
    - like 中以通配符开头(’%abc’)
    - 字符串不加单引号索引失效
    - or 连接索引失效
    - order by 或者 group by 违反最左匹配原则的情况下

3、explain
   id、select_type、table、partitions、type、possible_keys、key、key_len、ref、rows、Extra

4、B+树、B树
    - B+树单一节点存储更多的元素，使得查询的IO次数更少
    - B+树所有查询都要查找到叶子节点，查询性能稳定。
    - B+树所有叶子节点形成有序链表，便于范围查询
    - B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据
    - B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是
    - 查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束
    - B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次
    - 一个是数据的保存位置：B树保存在所有的节点中，B+树保存在叶子节点
    - 一个是相邻节点的指向：B树叶子节点之间没有指针，B+树有
    - B树的数据保存在所有节点，查询复杂度最好是 O(1)；B+树的数据保存在叶子节点，查询时间复杂度固定是O(log(n))
    - B树每个节点 key 和 data 在一起，则无法区间查找；B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等
    - B树每个节点即保存数据又保存索引，所以每一节点特别大，这一层所有节点加起来数据量将非常大。磁盘每次IO一定量的数据，对于Mysql来说如何衡量查询效率呢？就是		磁盘IO次数。既然B树每一层特别大，那每一层就需要对数据分开从而进行多次IO操作。所有Mysql不用。
      B+树更适合外部存储，也就是磁盘存储。由于内节点无 data 域，每个节点能索引的范围更大更精确，所以不需要用B+树
```



### 集群

```
1、模式 
	- MySQL Replication：一主多从的结构，主要目的是实现数据的多点备份（没有故障自动转移和负载均衡）
	- MySQL Fabirc：在MySQL Replication的基础上，增加了故障检测与转移，自动数据分片功能
					当该主节点挂了以后，会从从节点中选择一个来当主节点
	- MySQL Cluster：多主多从
	- MMM（Master Replication Manager for MySQL）：双主多从结构

2、CAP理论

3、mysql冷备、热备、温备
```



【事务】
- 隔离级别 - 读未提交、读已提交、可重复读以及可串行化； 脏读、不可重复读、幻读
- 事务ACID - 原子性、一致性、隔离性、持久性？？如何保证？？
- mvcc - 当前读、快照读


```markdown
【锁】
乐观锁 -  适用并发量不高的情况
悲观锁 - 
间隙锁 - 
排他锁（写锁）- 写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。
共享锁（读锁）- 读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。
死锁
意向锁 - X锁，IX锁
MDL锁 - 


MySQL 乐观锁悲观锁实现
事务ID，快照，原组数据
undo 事务
MVCC 快照读

MVCC能解决幻读吗？
快照读、当前读
```

存储引擎

1、MyISAM 、innodb 的区别
- InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。
  如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择
- MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务
  如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率


【SQL优化】
1、写完SQL先explain查看执行计划（SQL性能优化）
2、操作delete或者update语句，加个limit(SQL后悔药）
- 降低写错sql代价
- sql执行效率更高
- 可以避免长事务
- 数据量过大，容易把cpu打满
3、mysql回表
- 所谓的回表查询，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。
- 覆盖索引

【日志】
binglog
redolog
undolog


redis、mysql数据同步？？？？
- 1、基于消息中间件删除缓存
- 2、基于canal监听binlog删除缓存
- 3、延时双删

[mysql底层优化]


DQL/DML/DDL/TCL

二叉树、红黑树、hash表、B-Tree、B+-Tree

```markdown
1、sql优化一般思路

2、mysql集群如何实现高可用

3、数据量较大的如何分库分表

4、update如何加锁？？version如何实现？？

5、mysql常见的索引方式
 
6、DDL会加表锁吗？
perfacme 库，meta data lock 和 data lock 看事务持有锁的状态，可以判断是否加锁
DDL 5.7及以前会加表锁，8之后Online DDL 就不用加表锁

7、mysql深度分页如何解决？？

```





















