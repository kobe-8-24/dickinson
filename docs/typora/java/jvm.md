## 虚拟机

###  JVM内存模型

#### Java类的加载机制

```
类加载器
类加载机制
双亲委派模型
```

#### 运行时数据区

##### 线程共享

###### 堆

```
Heap是OOM故障最主要的发源地，它存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各子线程共享使用；通常情况下，它占用的空间是所有内存区域中最大的，但如果无节制地创建大量对象，也容易消耗完所有的空间；堆的内存空间既可以固定大小，也可运行时动态地调整，通过参数-Xms设定初始值、-Xmx设定最大值。

1、Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配
2、堆是在 Java 虚拟机启动时创建的
3、JVM主要管理两种类型的内存：堆和非堆（非堆即常说的栈）
4、简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的
5、方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中
```

###### 方法区（元空间）

```
存放 常量、静态变量、类信息

方法区是被所有线程共享的内存区域，用来存储已被虚拟机加载的类信息、常量、静态变量、JIT（just in time,即时编译技术）编译后的代码等数据。

运行时常量池是方法区的一部分，用于存放编译期间生成的各种字面常量和符号引用。
```

##### 线程私有

###### 程序计数器

```
程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
在虚拟机概念模型里（概念模型，各种虚拟机可能会通过一些更高效的方式实现），
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令：分支、跳转、循环、异常处理、线程恢复等基础操作都会依赖这个计数器来完成。
每个线程都有独立的程序计数器，用来在线程切换后能恢复到正确的执行位置，各条线程之间的计数器互不影响，独立存储。
所以它是一个“线程私有”的内存区域。
此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域。
```

###### 虚拟机栈（线程栈）

```
JVM栈是线程私有的内存区域。它描述的是java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至完成的过程，都对应着一个栈帧从入栈到出栈的过程。每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法。就像是组成动画的一帧一帧的图片，方法的调用过程也是由栈帧切换来产生结果。

局部变量表存放了编译器可知的各种基本数据类型（int、short、byte、char、double、float、long、boolean）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一跳字节码指令的地址）。

在JVM规范中，对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
```

###### 本地方法栈

```
1、本地方法 - native调用c c++
2、本地方法栈和虚拟机栈所发挥的作用是很相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。Sun HotSpot 直接就把本地方法栈和虚拟机栈合二为一。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。
```

#### 栈帧

```
堆栈以帧(栈帧)为单位保存线程的状态

jvm对堆栈只进行两种操作：以帧为单位的压栈和出栈操作

一个方法对应一块栈帧内存区域, 包含 局部变量表、操作数栈、动态链接、方法出口

javap 反汇编 查看 jvm指令手册
```

### GC

#### 堆内存 & 非堆内存

```
堆内存	(堆大小 = 新生代 + 老年代)
堆内存会从JVM启动参数（-Xmx:3G）指定的内存中分配

1、新生代
Eden、From Survivor、To Survivor（两个Survivor区解决内存碎片化）
内存大小比例为 8：1：1
新生代占比1/3
JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的因此，新生代实际可用的			    内存空间为 9/10 ( 即90% )的新生代空间

2、老年代
老年代占比2/3

非堆内存

1、永久代（元空间）
Perm不属于堆内存，有虚拟机直接分配，但可以通过-XX:PermSize -XX:MaxPermSize 等参数调整其大小。
```

#### 对象存活分析

```
引用计数

可达性分析算法
1、GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量
```

#### 垃圾收集器

```
1、CMS垃圾回收算法
缺点：对内存太敏感、容易产生碎片、不能解决浮动垃圾

2、G1垃圾回收算法
定义：以region为单位. 最大价值回收

3、ZGC垃圾回收算法
```

#### Java引用

```
强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）。
软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）。
弱引用：在GC时一定会被GC回收。
虚引用：由于虚引用只是用来得知对象是否被GC。
```

#### 内存逃逸分析

```
逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。

-XX:+DoEscapeAnalysis 开启逃逸分析
-XX:+PrintEscapeAnalysis 开启逃逸分析后，可通过此参数查看分析结果。
-XX:+EliminateAllocations 开启标量替换
-XX:+EliminateLocks 开启同步消除
-XX:+PrintEliminateAllocations 开启标量替换后，查看标量替换情况。

如果能证明一个对象不会逃逸到方法或线程外，则可能为这个变量进行一些高效的优化。

1. 栈上分配
我们都知道Java中的对象都是在堆上分配的，而垃圾回收机制会回收堆中不再使用的对象，但是筛选可回收对象，回收对象还有整理内存都需要消耗时间。
如果能够通过逃逸分析确定某些对象不会逃出方法之外，那就可以让这个对象在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，
就减轻了垃圾回收的压力。
在一般应用中，如果不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了。

2. 同步消除
线程同步本身比较耗时，如果确定一个变量不会逃逸出线程，无法被其它线程访问到，那这个变量的读写就不会存在竞争，对这个变量的同步措施可以清除。

3. 标量替换
Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们就可以称为标量。相对的，如果一个数据可以继续分解，
那它称为聚合量，Java中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，
那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化，
可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。
```

#### Jvm调优命令

```
Arthas
在使用 Arthas 之前，当遇到 Java 线上问题时，如 CPU 飙升、负载突高、内存溢出等问题，你需要查命令，查网络，
然后 jps、jstack、jmap、jhat、jstat、hprof 等一通操作。
最终焦头烂额，还不一定能查出问题所在。而现在，大多数的常见问题你都可以使用 Arthas 轻松定位，迅速解决，及时止损，准时下班。

jconsole

jmap
用来查看堆内存使用状况。jmap -heap pid可以看到当前进程的堆信息和使用的GC收集器，包括年轻代和老年代的大小分配等

jstack
主要用来查看某个Java进程内的线程堆栈信息。jstack pid 可以看到当前进程中各个线程的状态信息，包括其持有的锁和等待的锁。

jps 
主要用来输出JVM中运行的进程状态信息，一般使用jps命令来查看进程的状态信息，包括JVM启动参数等

jstat
进行实时命令行的监控，包括堆信息以及实时GC信息等。可以使用jstat -gcutil pid1000来每隔一秒来查看当前的GC信息


jprofiler
jprobe
yourkit
jhat
javap
jvisualvm

jinfo 
主要用来观察进程运行环境参数等信息
```

#### 性能调优

```
调优工具Arthas

Java三大性能调优参数 java -Xms128m -Xmx128m -Xss256k -jar xxxxx.jar
-Xms：堆的初始值，java堆的大小，-Xmx是其最大值
-Xmx：堆能达到的最大值
-Xss：规定了每个线程虚拟机栈（堆栈）的大小，一般256k就足够了，此配置会影响此进程中并发线程数的大小

jvm参数配置原则


```

#### gc问题排查过程

```
内存泄漏会导致内存溢出, 从而引发GC
栈内存溢出、堆内存溢出、方法区溢出

1、dump文件（dump命令详解）
2、mat分析
3、日志文件
```

#### gc回收算法

```
STW机制

标记复制 - 新生代
标记清除 - 老年代 （此算法会产生内存碎片）
标记整理 - 老年代 （此方法会整理内存碎片）

Java 中的堆也是 GC 收集垃圾的主要区域
GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。
minor gc -> major gc -> full gc -> oom
minor gc 发生在新生代，采用 标记-复制算法
Full GC/Major GC 发生在老年代，采用 标记 - 清除算法

本地模拟gc 
1、死循环
2、手动gc - system.gc()
```

#### 三色标记法

```

```

