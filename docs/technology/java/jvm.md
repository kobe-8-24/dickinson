## Referer

[Java基础----JVM详解](https://blog.csdn.net/pre_tender/article/details/102155860)

[JVM 详解，大白话带你认识 JVM](https://www.cnblogs.com/xzsj/p/xzsj-backend-java-jvm.html)

[JVM内存模型（详解）](https://zhuanlan.zhihu.com/p/101495810)

```
Java自带了一些用于分析Java应用程序和JVM的工具，这些工具可以帮助开发人员和系统管理员进行性能调优、内存分析和故障排查。以下是几种Java自带的分析工具：

jmap（Memory Map）：
用于生成Java进程的堆转储快照（heap dump），以及查看堆转储文件的信息。通过分析堆转储文件，可以了解Java堆内存中的对象分布、内存泄漏等问题。

jstack（Java Stack Trace）：
用于生成Java进程的线程转储快照（thread dump），显示所有线程的堆栈跟踪信息。这对于查找死锁、线程阻塞等问题很有帮助。

jstat（JVM Statistics Monitoring Tool）：
用于监视Java进程的各种运行时统计信息，包括垃圾回收情况、堆内存使用情况、类加载数量等。

jconsole（Java Monitoring and Management Console）：
图形化工具，提供对Java应用程序和JVM的监视和管理功能。可以通过jconsole实时监控应用程序的性能指标，并进行线程和内存分析。

jvisualvm（Java VisualVM）：
另一个图形化工具，是JDK自带的可视化监视和分析工具。提供线程分析、内存分析、垃圾回收分析等功能。

jcmd（Java Command）：
Java 7及以上版本提供的命令行工具，用于执行各种诊断命令。可以用来获取线程转储、堆转储，或执行各种运行时操作，如强制垃圾回收等。

jhsdb（JVM Serviceability Debugger）：
JDK 9及以上版本提供的高级调试工具，用于执行诊断命令和动态跟踪JVM的运行状态。

这些工具提供了丰富的功能，可以帮助开发人员定位和解决Java应用程序的性能问题和故障。使用这些工具需要一定的了解和经验，但对于Java应用程序的分析和调优来说是非常有价值的。
```

```
Java页面假死是指在Web应用程序中，页面长时间无响应或加载时间非常长，导致用户无法正常访问或操作页面。
这种情况可能由于多种原因引起，下面是详细的分析步骤：

1、确认页面假死：
首先，需要确认页面是否真的处于假死状态。可以通过多个客户端尝试访问页面，检查是否都无响应，或者使用浏览器的开发者工具查看页面请求和响应的状态。

2、检查服务器资源：
确保服务器的CPU、内存、磁盘等资源没有达到饱和状态。可以通过监控工具或者命令行查看服务器资源使用情况，避免因为服务器资源不足导致页面假死。

3、查看日志：
查找应用程序的日志文件，特别是错误日志和访问日志。检查是否有异常或错误信息，这可能会给出一些线索。

4、检查数据库连接：
如果页面中涉及数据库操作，确保数据库连接没有泄漏，以及数据库操作没有耗时过长。可以检查数据库连接池的配置和使用情况。

5、检查网络请求：
如果页面中有向外部服务发送网络请求，确保网络连接正常，没有超时或错误。可以通过网络监控工具查看网络请求的状态。

6、查看线程情况：
使用线程Dump（可以通过jstack命令获取）查看Java应用程序中的线程状态。检查是否有线程阻塞、死锁等情况。

7、分析代码逻辑：
仔细分析页面所涉及的代码逻辑，尤其是可能耗时的部分。查找是否存在性能瓶颈，比如循环次数过多、数据库查询频繁等。

8、使用性能分析工具：
使用一些性能分析工具，例如VisualVM、YourKit等，对Java应用程序进行性能分析，找出耗时操作和资源瓶颈。

9、压力测试：
进行压力测试，模拟多用户访问页面，观察系统的响应情况和性能表现。这有助于找出系统在高负载下的问题。

10、调整服务器配置：
根据分析结果，可能需要调整服务器的配置，如增加内存、优化数据库配置等，以提高系统的性能和稳定性。

页面假死问题可能是复杂的，可能需要综合使用多种方法才能找到根本原因。及时记录并分析日志，保持监控和性能测试的习惯，可以帮助更好地定位和解决页面假死问题。
```

```markdown
常见的垃圾收集器

cms、g1 可预测停顿时间、stw

jvmti、jps、jmap、jstack、arthas、jconsole、jhat、jvisualvm、mat工具

oom问题排查

直接内存技术
 
类加载器、双亲委派模型

jit预编译

io内存模型
```

- oom如何排查
- cpu 100%如何排查
- 死锁 cpu利用率多少？while true会cpu 升高吗？频繁youngGc 、线程数很高
- 页面假死如何排查

[【6问6答】JAVA 应用 CPU 使用率为什么飚升？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/58338577?utm_id=0)

[死锁一定会造成cpu使用率飙升吗？_数据库死锁会导致cpu过高吗_dotsee的博客-CSDN博客](https://blog.csdn.net/qq_25188255/article/details/90456778)

[线上服务Java进程假死快速排查、分析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/529350757)

**什么情况下我们需要破坏双亲委派模型**

```properties
双亲委派模型（Parent Delegation Model）是Java类加载器的一种工作模式，用于加载类和资源。在这个模型中，每个类加载器都有一个双亲（parent）加载器，它会尝试加载类，如果找不到，则会委派给它的双亲加载器，一直追溯到根加载器。只有在所有双亲加载器都无法加载类时，才会由当前加载器尝试加载。

破坏双亲委派模型通常是一种不建议的做法，因为它可能导致类加载的混乱和冲突，破坏了Java类加载器的原本设计思想。但在某些特定情况下，可能需要考虑破坏双亲委派模型：

1. **自定义类加载器：** 如果你需要实现自定义类加载器，以实现特定的加载逻辑，如动态加载类，实现热部署等，你可能需要破坏双亲委派模型。自定义加载器可以在父加载器无法加载类时，尝试自己加载。

2. **类隔离：** 在某些情况下，你可能需要隔离不同的类加载器，以确保它们加载的类互不干扰。这通常出现在一些应用服务器或框架中，每个应用都有自己的类加载器，以防止类冲突。

3. **动态代理和字节码增强：** 一些框架和库，如Spring和Hibernate，使用动态代理和字节码增强来实现AOP（面向切面编程）等功能，这可能需要破坏双亲委派模型以加载被代理的类。

需要注意的是，破坏双亲委派模型可能会导致类加载的复杂性和潜在的问题，因此应该慎重使用，并确保清楚了解其影响和潜在风险。在大多数情况下，最好遵循Java的类加载器机制，只有在确实需要时才考虑破坏这种模型。
```

